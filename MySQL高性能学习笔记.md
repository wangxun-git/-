## MySQL高性能学习笔记

#### 一、MySQL架构与历史

MySQL的灵活性体现：

+ 可以运行在不同的硬件上，支持不同的数据类型。
+ 存储引擎结构：将查询处理及其他系统任务和数据的存储/提取相分离。可以在使用时根据性能、特性以及其他需求来选择数据存储的方式。

##### 1、MySQL逻辑架构

**MySQL服务器逻辑架构图：**

![image-20200806112420203](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200806112420203.png)

+ 最上层服务并不是MySQL独有，大多数基于网络的客户端/服务器的工具或服务都有类似架构。比如：连接处理、授权认证、安全等。
+ 第二层架构：大多数MySQL核心功能都在这一层，包括SQL解析、分析、优化、缓存以及所有的内置函数；所有的跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。
+ 第三层架构：包含存储引擎：将数据以不同技术存储在文件中。它负责MySQL中数据的存取和提取，但是存储引擎不会去解析SQL(InnoDB存储引擎会解析外键定义，因为MySQL服务器本身没有实现该功能)。服务器通过API和存储引擎进行通信。服务接口屏蔽了不同存储引擎之间的差异。存储引擎API包含很多底层函数，不同存储引擎之间不会产生通信，只是简单的响应上层服务器的请求。

###### 1、连接管理与安全性

+ MySQL5.5以上的版本提供支持线程池插件，可以使用线程池中少量的线程服务大量的连接。
+ 当客户端连接服务器时，首先进行身份验证。认证成功之后，服务器会继续验证客户端是否有执行某个特定操作的权限。

###### 2、优化并执行

+ MySQL解析SQL，会创建内容数据结构(解析数)，然后对其进行各种优化：重写查询、选择合适索引、决定表的读取顺序等。
+ 可以请求优化器解释优化过程中的各个因素，使用一些关键字提示优化器。
+ 优化器不关心表使用的什么存储引擎，但是存储引擎会对优化查询有影响：优化器会请求存储引擎提供容量或某个具体操作的开销信息、表数据的统计信息等。

##### 2、并发控制

+ MySQL在服务器层和存储引擎层来处理并发控制问题。

###### 1、读写锁

+ 锁系统：共享锁(读锁)+排他锁(写锁)。
+ 读锁：共享的，相互不阻塞的。多个客户在同一时刻同时读取同一资源而互不干扰。
+ 写锁：排他的，处于安全考虑，一个写锁会阻塞其他的写锁和读锁。一个用户在执行写入操作时，其他用户不可以进行读取和写入操作。

###### 2、锁粒度

+ 让锁定对象更有选择性，尽量只锁定需要修改的数据片，而不是所有资源。在给定的资源上，锁定的数据量越少，则系统的并发程度越高。
+ 锁策略：加锁需要消耗资源，在锁的开销和数据的安全性之间寻求平衡。MySQL中的每种存储引擎都可以实现自己的锁策略和锁粒度。将锁粒度固定在某个级别，对于某些特定的应用场景可以提供更好的性能服务，在也会失去其他场景下的性能。
+ **表锁(table lock)：**开销最下的锁；会锁定整张表；写锁比读锁拥有更高的优先级，所以写锁请求会被插入读锁队列的前面。在特性的场景下，表锁可以有很好的性能表现。
+ **行级锁(rwo lock)：**可以最大程度的支持并发处理，但也带来很大的开销。行级锁**只在存储引擎**中实现。

##### 3、事务

+ 事务：一组原子性的SQL查询，一个独立的工作单元。事务内的语句，要么全部执行成功，要么全部执行失败。
+ ACID：原子性、一致性、隔离性、持久性。一个运行良好的事务处理系统，必须具备这些标准特征。
  + 原子性：一个事务必须被视为一个不可分割的最小单元，整个事务中的操作要不全部执行成功，要不全部执行失败。
  + 一致性：数据库总是从一个一致性到另一个一致性的状态，也就是说事务如果没有提交，即使中间出现服务器出错，数据也不会发生改变。
  + 隔离性：一个事务所做的写入操作在事务最终被提交以前，对其他事务是不可见的。
  + 持久性：一旦事务被提交，其所做的写入操作会被永久保存到数据库中。
+ 事务处理过程中需要做很多额外操作，一般需要占用很多的资源。MySQL的存储引擎可以让我们根据业务是否需要事务处理来选择合适的存储引擎。

###### 1、隔离级别

+ 提供四种隔离级别，每一种隔离级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见，哪些是不可见的。级别较低的隔离通常可以执行更高的并发，系统的开销也更低。

**隔离级别：**

+ **READ UNCOMMITED(未提交读)：**事务中的修改，即使没有提交，也会对其他事务可见。
  + **脏读：**事务可以读取未提交的数据。
+ **READ COMMITED(提交读、不可重复读)：**事务只能看见已经提交的事务所做的修改。一个事务从开始到提交中间所做的任何操作对其他事务都是不可见的。
+ **REPEATABLE READ(可重复读)：**MySQL的默认事务隔离级别。解决了脏读问题。该级别保证了在**同一个事务中**多次读取同样的记录的结果是一致的。
+ **幻读：**当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录，会产生幻行。
+ **可串行化(SERIALIZABLE)：**最高隔离级别，强制事务串行执行。会在读取的每一行数据上都加锁

|  隔离级别  | 脏读可能性 | 不可重复读可能性 | 幻读可能性 | 加锁读 |
| :--------: | :--------: | :--------------: | :--------: | :----: |
|  未提交读  |    YES     |       YES        |    YES     |   NO   |
| 不可重复读 |     NO     |       YES        |    YES     |   NO   |
|  可重复读  |     NO     |        NO        |    YES     |   NO   |
|  可串行化  |     NO     |        NO        |     NO     |   NO   |

###### 2、死锁

+ **死锁：**两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。
  + 当多个事务以不同的顺序锁定资源时，可能会产生死锁。
  + 多个事务同时锁定同一个资源时，会产生死锁。
+ 数据库系统提供了各种死锁检测和死锁超时机制。InnoDB存储引擎处理死锁的方法：将持有最少行级排他锁的事务进行回滚。
+ 锁的行为和顺序和存储引擎相关的。死锁的产生有双重原因：
  + 有些是因为真正的数据冲突。
  + 有些是因为存储引擎的实现方式导致的。通过回滚其中的一个事务来释放锁，打破死锁。

###### 3、事务日志

+ 可以提高事务的效率。使用事务日志，存储引擎在修改表数据时只需要修改其**内存拷贝**，再把修改行为记录在持久在硬盘上的事务日志中，不用每次都把修改数据持久化到磁盘。
+ 事务日志采用追加的方式。
+ 预写式日志：事务日志持久后，内存中被修改的数据在后台可以慢慢的写入磁盘，修改数据需要写两次磁盘。

###### 4、MySQL中的事务

+ MySQL提供两种事务型存储引擎：InnoDB、NDB Cluster。
+ MySQL采用自动提交模式，如果不是显示的开始一段事务，则每个查询都被当作一个事务执行提交操作。
+ 在事务中可以混合使用存储引擎，如果在事务中混合了事务性和非事务性的表，正常情况下，提交是没有错误的，但是在回滚时会报错。
+ InnoDB采用两阶段锁定协议。在事务执行过程中，随时可以执行锁定，所有锁会在COMMIT或者ROLLBACK时才会被释放。这是隐式锁定，InnoDB可以根据隔离级别在需要的时候自动加锁。
+ InnoDB可以通过特定的语句进行显式加锁。
+ MySQL支持**LOCK TABLES和UNLOCK TABLES**语句，这是在服务器层实现，但是这并不能替代事务处理。

##### 4、多版本并发控制

+ 多版本并发控制(MVCC)：行级锁的一个变种，在很多情况下避免了加锁操作，因此开销很少，大都实现了非阻塞的读操作，写操作只锁定必要的行。
+ MVCC的实现是通过保存数据在某个时间的快照来实现的。不管执行多产时间，每个事物看到的数据都是一样的。
+ MVCC实现方式有：**乐观锁**、**悲观锁**
+ **丢失更新：**两个用户(或以上)对同一个对象操作引起的数据丢失。

|   锁   |                             含义                             |
| :----: | :----------------------------------------------------------: |
| 悲观锁 | 1、假设丢失更新一定存在，SQL后面加上for update；这是数据库的一种机制。    2、在进行操作数据操作时，都要通过获取锁才能进行对相同数据的操作，由数据库实现，在使用时可以通过调用数据库的相关语句来实现。  3、悲观锁：共享锁、排他锁。 |
| 乐观锁 | 1、假设丢死更新不一定发生。update时候存在版本号，更新的时候根据版本号进行更新。     2、乐观锁不是数据库自带的，需要我们去实现。   3、乐观锁：操作数据库时(更新操作)，想法更乐观，认为这次操作不会造成操作，所以在操作数据时，不进行加锁操作，而是在更新完之后，再去判断是否有冲突的问题。    4、如何实现：（1）在操作数据时，先给数据表添加一个版本字段。（2）每进行一次操作更新时，都会先查询出那条数据的version，然后判断此刻的version是否与刚刚查询出的version的值时候相等，如果相等，则进行操作，然后version+1，反之不可。 |

+ InnoDB中MVCC是通过在每一个行记录后面保存两个隐藏的列来实现的。两个列：**保存了行创建的时间**、**保存行的过期时间**。存储的是系统版本号。每开始一个事务，系统版本号都会自动递增。
+ MVCC只在**PEPEATABLE READ、READ COMMITED**两个隔离级别下工作。

**PEPEATABLE READ隔离级别下的MVCC具体实现方式：**

|  DDL   |                           如何操作                           |
| :----: | :----------------------------------------------------------: |
| SELECT | 1、InnoD只查找版本小于或等于当前事务版本的数据行，确保事务读取的行是在事务开始之前就已经存在的，或者是事务自身插入或者修改的。 |
| INSERT |    InnoDB为新插入的每一行保存当前系统版本号作为行版本号。    |
| UPDATE | InnoDB为插入一行新记录，保存当前的系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。 |
| DELETE |    InnoDB为删除的每一行保存当前系统版本号作为行删除标识。    |

##### 5、MySQL中存储引擎

+ MySQL将每个数据库(schama)保存为数据目录下的一个子目录。
+ 创建表时，MySQL会在数据库子目录下创建一个和表同名的.frm文件保存表的定义。表的定义是在MySQL服务层统一处理。
+ MySQL使用文件系统的目录和文件保存数据库和表的定义，大小写敏感性和具体的平台密切相关。

###### 1、InnoDB存储引擎

+ InnoDB被设计用来处理大量的短期事务，短期事务大多是正常提交的，很少被回滚。
+ InnoDB的数据存储在表空间中。**表空间：**是由InnoDB管理的一个黑盒子，由一系列的数据文件组成，InnoDB可以将每个表的数据和索引放在单独的文件中。
+ InnoDB支持MVCC的四个标准的隔离级别，默认级别是**可重复读**，并且通过**间隙锁**策略防止幻读。**间隙锁：**对索引记录间的范围加锁。
+ InnoDB表是基于**聚簇索引**建立的，聚簇索引对主键查询有很高的的性能，但是它的非主键索引必须包含主键列。
+ InnoDB内部做了很多优化，例如：从磁盘读取数据时采用的可预测性预读，通过在内容中创建hash索引；加速插入的插入缓冲区。
+ InnoDB通过一些机制和工具支持热备份。

###### 2、MyISAM存储引擎

+ MyISAM不支持事务和行级锁。
+ MyISAM会将表存储为两个文件：数据文件(.MYD)、索引文件(.MYI)。
+ MyISAM对整张表进行加锁，读取时对读取的表加共享锁，写入时加入排他锁，也可以支持并发插入。
+ 对于MyISAN表，MySQL支持手工或者自动执行检查和修复操作。
+ MyISAM支持全文索引。**全文索引：**可以通过关键字的匹配来进行查询过滤，实现基于相似度的查询。
+ 创建MyISAM表时，如果指定DELAY_KEY_WRITE选项，在每次修改完成之后，不会立刻将修改的索引数据写入磁盘，而是会先存入内存中的缓冲区，在清理缓冲区或者关闭表的时候才会将对应的索引写入磁盘。
+ MyISAM压缩表适合创建之后不会再去修改的，可以极大的减少磁盘占用时间、磁盘I/O。

###### 3、其他存储引擎

| 存储引擎  |                           相关介绍                           |
| :-------: | :----------------------------------------------------------: |
|  Archive  | 缓存所有的写操作，利用zlib对插入的行进行压缩，占用的磁盘I/O较少。select会执行全盘扫描。比较适合日志和数据采集类应用，以及需要快速进行insert的场合。支持行级锁和专用的缓冲区，可以实现高并发的插入。 |
| Blackhole |               适用于特殊的复制架构和日志审核。               |
|    CSV    | 将普通的CSV文件(逗号分隔值的文件)作为MySQL的表来处理，但并不支持索引。可以作为一种有效数据转换的机制。 |
| Federated | 是访问其他MySQL服务器的一个代理，创建到远程MySQL服务器的一个客户端连接，实现数据传输。 |
|  Memory   |        数据保存在内存中，可以快速访问，但无法持久化。        |
|   Merge   |           Merge表是由多个MyISAM表合并而来的虚拟表            |
|  NDB集群  |               作为SQL和NDB原生协议之间的接口。               |

#### 二、MySQL基准测试

+ 基准测试是对系统设计的一种压力测试。

##### 1、为什么需要基准测试

+ 是唯一有效的、可以学习系统在给定的工作负载下会发生的方法。可以观察系统在不同压力下的行为。
+ 基准测试施加给系统的压力相对真实压力来说通常比较简单。

##### 2、基准测试的策略

+ 两种测试策略：**对整个系统的整体测试(集成式)**、**单独测试MySQL(单组件式)**

###### 1、测试何种指标

+ 在开始执行甚至是在设计基准测试之前，需要先明确测试的目标。
+ 测试目标决定了选择什么样的测试工具和技术，以获得精确而有意义的测试结果。
+ **吞吐量：**指单位时间内的事务处理数。非常适用于多用户的交互式应用。
+ **响应时间或者延迟：**测试任务所需的整体时间。
+ **并发性：**并发性基准测试关注正在工作中的并发操作，或者同时工作中的线程数或者连接数。
+ **可扩展性：**给系统增加一倍的工作，在理想情况下的吞吐量可以增加一倍。

##### 3、基准测试方法

+ 如果其他条件相同，应该努力使测试过程尽可能的接近真是应用的情况。

###### 1、设计和规划基准测试

+ 提出问题并明确目标，然后决定是采用标准的基准测试，还是设计专用的测试。
+ 可以在不同级别记录查询。
+ 详细的写下测试规划。
+ 建立将参数和结果文档化的规范，每一轮测试都必须进行详细记录。

###### 2、基准测试应该运行多长时间

+ 等系统的看起来稳定的时间至少等于系统预热的时间。

###### 3、获取系统性能和状态

+ 在执行官基准测试时，需要尽可能多的收集被测试系统的信息。

##### 4、基准测试工具

+ 集成式测试工具：**ab、http_load、jMeter**。
+ 单组件测试工具：**mysqlslap、MySQL Benchmark Suite(sql-bench)、Super Smack、Database Test Suite等**

#### 三、服务器性能剖析

+ 使用性能剖析专注于测量服务器的时间花费在哪里。

##### 1、性能优化简介

+ 性能定义：完成某件任务所需的时间度量。
+ 无法测量就无法有效的优化性能；选择合适的测量范围。
+ 完成一件任务所需的时间分为两部分：**执行时间**、**等待时间**，针对这两种不同的时间有不同的优化方案。

###### 2、通过性能剖析进行优化

+ 性能剖析是测量和分析时间花费在哪里的主要方法。主要步骤
  + 1、测量任务所花费的时间
  + 2、对结果进行统计和排序，将重要的任务排在前面
+ 基于执行时间的分析研究是什么任务的执行时间最长。
+ 基于等待的分析则是判断任务在什么地方被阻塞的时间最长。
+ 在对系统进行性能剖析前，必须要先进行测量。

##### 2、对应用程序进行性能剖析

+ 对任何需要消耗时间的任务都可以做性能剖析。
+ New Relic。

##### 3、剖析MySQL查询

###### 1、剖析服务器负载

+ 在服务器端可以有效的审计效率低下的查询。定位和优化“坏”查询能够显著地提升应用性能，还可以降低服务器的整体压力，这样所有的查询都会因为减少了对共享资源的争用而受益。
+ 慢查询日志比较适合用来做测量工具。
+ 通用日志：在查询请求到服务器时进行记录，不包含响应时间和执行计划等信息，不适合用来做分析和剖析服务器性能。

###### 2、剖析单条查询

+ **SHOW PROFILE**：查询剖析工具。
+ **SHOW STATUS**：返回一些计数器；既有服务器级别的全局计数器，也有基于某个连接的会话级别的计数器。

###### 3、使用性能剖析

+ 优化查询时，需要对服务器如何执行查询有较深的了解。

##### 4、诊断间歇性问题

+ **间歇性的问题：**比如系统偶尔停顿或者慢查询，很难诊断。尽量不要使用试错的方式来解决问题。

#### 四、Schema和数据类型优化

+ 良好的逻辑设计和物理设计是高性能的基石，应该根据系统要执行的查询语句来设计Schema。

##### 1、选择优化的数据类型

+ 更小的通常更好：正常情况下，应该使用正确存储数据的最小数据类型。
+ 简单更好：简单数据类型的操作通常需要更少的CPU周期。
+ 尽量避免null：因为可为NULL的列使得索引、索引统计和值比较都变得更为复杂。

###### 1、整数类型

+ 整数类型：TINYINT、SMALLINT、MEDIUMINT、INY、BIGINT。

###### 2、实数类型

+ 是带有小数部分的数字。但也可以使用DECIMAL存储比BIGINT还大的整数。

###### 3、字符串类型

+ VARCHAR：可变长字符串，只需要必要的空间。
+ CHAR：定长字符串，根据定义的字符串长度分配固定的时间。

###### 4、日期和时间类型

+ TIMESTAMP要比DATETIME的空间效率更高。

##### 2、MySQL中Schema的设计

+ **太多的列：**存储引擎API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲区内容解码成各个列。
+ **太多的关联：**MySQL限制了每个关联操作最多只能有61张表。

##### 3、范式和反范式

**范式的优点：**

+ 范式化的更新操作通常比反范式要快，因为很少或没有重复数据。
+ 范式化的表通常更小，可以更好地放在内存中。

**范式的缺点：**

+ 通常需要关联，

###### 1、混用范式化和反范式化

+ 最常见的反范式化数据的方法是复制或者缓存，在不同的表中存储相同的列。

##### 4、缓存表和汇总表

+ **缓存表：**表示存储那些可以比较简单地从schema其他表获取数据的表。
+ **汇总表：**保存的是使用ORDER BY语句聚合数据的表。

##### 5、加快ALTER TABLE操作的时间

+ MySQL中的ALTER TABLE的操作性能对于数据量比较大的表来说是个大问题。

###### 1、只修改.frm文件

+ 新建一个**.frm**文件，然后替换到需要更改的文件。

###### 2、快速创建MyISAM索引

+ 为了高效的把数据载入到MyISAM表中，可以先禁用索引，载入数据，然后重启索引。

